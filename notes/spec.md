## Project Structure

```
~/CekhmetProjects/my_project
    -> my_project.sekproj           (Json config file for the project containing, among other things, path to the engine install dir and list of plugin & asset package sub-projects)
    -> config                       (Directory containing categories of the config registry other than the build config)
        -> editor.json              (Config categories containing project-specific editor settings)
        -> my_plugin_config.json
        -> ...
    -> assets                       (Directory containing project-specific asset packages & asset package subprojects)
        -> external_pack.sekpak     (External asset package which is not a subproject, but is still loaded by the engine accorging to the project config)
        -> my_package               (Each package subproject receives it's own subdirectory)
            -> my_package.assetproj (Json config file containing information about the package subproject)
            -> .projignore          (File used to specify project ignore patterns)
            -> .import              (Directory containing asset import cache, used to store asset format handler settings)
                -> my_resource.ubj.imp
                -> my_image.png.imp
            -> my_resource.ubj
            -> my_image.png
    -> plugins                      (Directory containing plugin subprojects)
        -> my_plugin                (Each plugin receives it's own subdirectory)
            -> my_plugin.pluginproj (Json config file containing information about the plugin subproject)
            -> .projignore          (File used to specify project ignore patterns)
            -> CMakeLists.txt       (CMake project file of the plugin's subproject)
            -> CMakeGenerated.txt   (CMake file containing configuration generated by the engine for each project, must be included by CMakeLists.txt)
            -> project sources...
    -> build                        (Directory containing project build artifacts)
        -> linux-x86_64             (Build platform-specific subdirectory)
            -> export-release
            -> export-debug
            -> editor       
```

## Config registry

TODO: Rework config registry specification.

## Asset packages

## Resources

Resources are runtime types serialized into assets. Every resource asset has a tag with a `resource` key and value
being the type of the resource. Every resource type must have the `sek::attributes::serializable_resource`
attribute associated with it. This attribute is used to make the resource (de)serializable at runtime.

## Editor projects

Inside a single editor instance can exist multiple projects. The "main" project is always present - it is the project of
the current working directory of the editor. Additionally, a "main" project can contain one or multiple plugin and/or
asset subprojects. These subprojects define individual plugin and asset packages built and exported as part of the "
main" project.

### Plugin projects

Plugin projects are subdirectories within the `plugins` directory, containing a `.pluginproj` file. `.pluginproj`
contains all project-specific configuration of a plugin project, such as the toolchain used (ex. CMake) and file
types associated with project sources (if not specified, the "main" project default is used), and a list of sources of
the plugin.

Once a plugin project is modified by creating new files or updating its configuration (or a new one is generated), the
corresponding toolchain is used to generate required project files for the target build system (ex. CMake toolchain
generates CMake project files).

If a source file of the plugin project is modified and either the plugin project or the "main" project has the
auto-compile option enabled, or the user requests a manual (re)compilation, or the plugin has been compiled externally (
and thus the output binaries have been modified), the plugin is queued for hot-reload. Plugins can only be hot-reloaded
if the play mode is not on, since reloading plugins requires serialization & unloading of all resources and
configuration and a soft-reset of the engine state. This is required in order to avoid leaving dangling references to
code or data of the unloaded plugins.

When a plugin project is built, the corresponding toolchain is used to configure and invoke the build system used for
the project.

### Asset projects

Asset projects are subdirectories within the `assets` directory, containing a `.assetproj` file. `.assetproj` contains
all project-specific configuration of an asset package project, such as the information about asset aliases and import
cache.

When an asset file within an asset project is modified or a new file is created, an asset format handler corresponding
to the file's type is selected. This format handler is then used to "build" the asset for the current platform and
target, and may then generate and/or update any number of asset artifacts, which are additional build files
produced from the asset. Any persistent information about the asset import process (such as, for example, version of the
asset format) can be stored within the asset import cache (`.imp`) file. Any additional information about the imported
asset required at runtime can be stored within the asset's key-value tags (ex. `resource: [type]`).

Asset import cache files are created for every imported asset, regardless of whether the format handler uses it
to store any data or not. Editor uses import cache files as a way to verify if an asset has already been imported
previously or not upon modification or discovery of the asset file. If an asset import cache file is missing, the asset
is treated as a new asset, otherwise the format handler is used to update (re-import) the asset instead.

TODO: Write specification for asset aliases and build files.

Notably, asset format handlers may store additional global application state used to preform certain actions within the
editor. For example, the shader definition handler stores a database of all shader assets from every asset project,
which can be used to re-compile all shader assets without manually searching and re-building shader assets from all
asset projects.

### Plugin and asset project config

The `.pluginproj` and `.assetproj` files contain Json configuration of the asset projects. While this per-project
configuration is accessible from the Editor Project Manager, it is also accessible directly from the config registry via
a config path in the following format: `/project/assets/<project-name>` for asset package projects and
`/project/plugins/<project-name>` for plugin projects, where `project-name` is the name of the project whose
configuration to retrieve. Note that the project name is the same as it's subdirectory within `assets` or `plugins`
respectively. Additional configuration can be stored within the asset or plugin subproject using these config paths.

### Project ignore files

Both asset and plugin projects can contain any number of `.projignore` files. These files are used to specify ignore
patterns for the specific project. These ignore patterns are used by the editor to filter directories used for automatic
content discovery and modification tracking.

The format of `.projignore` files is similar to `.gitignore`, however it also allows to specify the type of ignore
pattern. By default, ignore patterns are applied both in editor and export builds. Patterns placed under
the `[[editor]]` tag will be only applied in editor and patterns placed under the `[[export]]` will be only applied in
export builds respectively.

If a `.projignore` file is missing, the default ignore rules are used, which are equivalent to the
following `.projignore` file:

```
**/.*

[[export]]
**/[Ee]ditor*
```

As such, all directories and files starting a `.` (hidden) are ignored in both editor and export builds, and all
directories and files starting with `editor` or `Editor` are ignored in export builds.

## Editor asset pipeline

TODO: Rework asset pipeline specification.

## Project properties

TODO: Rework project properties specification.

## Shader definition assets (OverPass)

TODO: Rework OverPass specification.

## Project build and toolchains

1. Plugin toolchain - User-configurable for each project, defines the project generator & build interface (ex. CMake).
2. Build target - User-configurable set of rules for each plugin & shader toolchain (such as compile-time definitions),
   target-specific project properties and environment variables.
3. Graphics API - Definition of a graphics API (ex. Vulkan). Specifies the render server, shader toolchain (code
   generator & compiler) and other API-specific configuration (such as project properties).
4. Build platform - Definition of a target platform (ex. linux-x86_64). Specifies the list of allowed graphics APIs and
   plugin toolchains, the selected graphics API, platform-specific project properties and environment variables.

Projects are built under the `build` directory. Every platform receives its own subdirectory, which contains further
subdirectories for every build target (ex. `build/linux-x86_64/export-release`).

Editor builds use the build platform of the editor executable. The in-editor graphics API and build target can be
configured by the user (if a different graphics API is selected, a full restart of the editor is required).

## Main loop

Each iteration of the main game loop preforms the following operations:

![](../main_loop_diagram.png)

## Addendum

* Editor plugins - Any plugin that provides in-editor functionality is called an editor plugin. Internally, the engine
  does not differentiate between editor plugins and regular plugins.
