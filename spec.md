## Project Structure

```
~/CekhmetProjects/my_project
    -> my_project.sekproj           (Json config file for the project containing, among other things, path to the engine install dir and list of plugin & asset package sub-projects)
    -> config                       (Directory containing "documents" of the config registry other than the build config)
        -> editor.json              (Config "document" containing project-specific editor settings, such as the current layout, )
        -> my_plugin_config.json
        -> ...
    -> assets                       (Directory containing project-specific asset packages & asset package subprojects)
        -> external_pack.sekpak     (External asset package which is not a subproject, but is still loaded by the engine accorging to the project config)
        -> my_package_a             (Each package subproject receives it's own subdirectory)
            -> .assetproj           (Json config file containing information about the package subproject)
            -> .import              (Directory containing asset import cache, used to store asset format handler settings)
                -> my_resource.ubj.imp
                -> my_image.png.imp
            -> .artifacts           (Directory containing asset artifacts)
                -> my_image.png.tex
            -> .metadata            (Directory containing asset metadata)
                -> my_resource.ubj.meta
            -> my_resource.ubj
            -> my_image.png
    -> plugins                      (Directory containing plugin subprojects)
        -> my_plugin                (Each plugin receives it's own subdirectory)
            -> .pluginproj          (Json config file containing information about the plugin subproject)
            -> CMakeLists.txt       (CMake project file of the plugin's subproject)
            -> CMakeGenerated.txt   (CMake file containing configuration generated by the engine for each project, must be included by CMakeLists.txt)
            -> project sources...
    -> bin                          (Directory containing compiled binaries of the plugin sub-projects)
        -> editor                   (In-editor binaries with debug information and editor-specific functionality)
        -> debug                    (Export binaries with debug information)
        -> release                  (Export binaries with no debug information)
```

## Config registry

Engine stores it's configuration in the config registry system. Config registry contains a tree with every node being
accessed via a config path, which are similar to unix file paths, with every node containing multiple children as well
as optional entry data.

Registry is separated into "documents", with each document representing an independent config tree. Documents can be
saved and restored from json files. Whenever a document is read from file or directly from a json input archive, it is
deserialized into the registry node tree. Document files, however may contain more nodes than are currently not present
within the registry, to account for this, the registry keeps track of the files the documents have been loaded from and
de-serializes the nodes as they are registered.

Editor plugins may add registry entries to the config menu, in which case the config menu can be used to edit
corresponding registry entries. Additionally, editor plugins may add registry entries to config export list, in which
case such entries will be serialized and built into the export binary. It is recommended that if the entry has ability
to provide defaults or does not need to export all it's data (ex. entries may contain data relevant only within the
editor), a different underlying type should be used for export serialization, this can reduce the amount of exported
data.

## Asset packages

## Resources

Resources are runtime types serialized into assets. Resource assets' metadata specifies the format version and the type
name of the resource (for version 1).

Every resource type must have the `sek::engine::attributes::resource_type` attribute associated with it. This
attribute is used to make the resource (de)serializable at runtime using the specified serialization archive (UBJson is
used by default).

## Editor projects

Inside a single editor instance can exist multiple projects. The "main" project is always present - it is the project of
the current working directory of the editor. Additionally, a "main" project can contain one or multiple plugin and/or
asset subprojects. These subprojects define individual plugin and asset packages built and exported as part of the "
main" project.

### Plugin projects

Plugin projects are subdirectories within the `plugins` directory, containing a `.pluginproj` file. `.pluginproj`
contains all project-specific configuration of a plugin project, such as the toolchain used (ex. CMake) and file
types associated with project sources (if not specified, the "main" project default is used), and a list of sources of
the plugin.

Once a plugin project is modified by creating new files or updating its configuration (or a new one is generated), the
corresponding toolchain is used to generate project files for the target build system (ex. CMake toolchain generates
CMake project files).

When a plugin project is built, the corresponding toolchain is used to configure and invoke the build system used for
the project.

### Asset projects

Asset projects are subdirectories within the `assets` directory, containing a `.assetproj` file. `.assetproj` contains
all project-specific configuration of an asset package project, such as the information about asset aliases, artifacts
and import cache.

When an asset file within an asset project is modified or a new file is created, an asset format handler corresponding
to the file's type is selected. This format handler may then generate and/or update any number of asset artifacts, which
are additional files produced from the asset. Any persistent information about the asset import process (such as, for
example, version of the asset format) can be stored within the asset import cache.

Asset import cache (`.imp`) files are created for every imported asset, regardless of whether the format handler uses it
to store any data or not. Editor uses import cache files as a way to verify if an asset has already been imported
previously or not upon modification or discovery of the asset file. If an asset import cache file is missing, the asset
is treated as a new asset, otherwise the format handler is used to update (re-import) the asset instead.

If an artifact created for an asset is missing or build option requirements of an asset alias have changed, the format
handler is used to re-generate asset artifacts using the existing import cache (asset is re-imported).

Format handler may also create any number of asset aliases, which are used to map imported assets' paths to the (
potentially artifact) files that contain data of said assets. Asset aliases that do not point to an asset artifact, nor
have any build option filters are known as "identity" aliases. Identity asset aliases simply point to the file of the
import asset, which is always exported during build. If a format handler does not create any aliases for the imported
asset file, an identity alias is automatically created instead.

Asset aliases can contain optional project build option filters. These filters are used to selectively enable or disable
aliases based on build options. When an asset project is built, all asset aliases are resolved and only the aliased
files are exported. This is done in order to ignore the source assets and only export the relevant artifacts, as well as
to avoid exporting files that have been disabled through aliases.

Notably, asset format handlers may store additional global application state used to preform certain actions within the
editor. For example, the shader definition handler stores a database of all shader assets from every asset project,
which can be used to re-compile all shader assets without manually searching and re-importing shader assets from all
asset projects.

### Plugin and asset project config

The `.pluginproj` and `.assetproj` files contain Json configuration of the asset projects. While this per-project
configuration is accessible from the Editor Project Manager, it is also accessible directly from the config registry via
a config path in the following format: `/project/assets/<project-name>` for asset package projects
and `/project/plugins/<project-name>` for plugin projects, where `project-name` is the name of the project whose
configuration to retrieve. Note that the project name is the same as it's subdirectory within `assets` or `plugins`
respectively.

## Editor asset import

## Editor properties

## Shader definition assets

In order to streamline & simplify shader creation process, shaders are defined using a custom node-centric language.
Assets of this intermediate shader definition language are then compiled into individual shader kernels (1 or multiple
per shader definition).

Import pipeline of the shader definition assets is roughly as follows:

1. Parse shader definition into generic shader metadata & shader programs.
2. Generate "shader program" asset aliases and the shader resource asset.
3. Generate shader source of individual shader programs for the target graphics API.
4. Compile the generated shader code into "shader program" assets for the current API.

Shader definition language is used to define metadata - external variables, permutation switches and includes, shader
nodes - abstract building blocks of shader programs, shader stages - stages of an individual shader pass such as
the `vertex` and `fragment` stages, and shader passes - individual collections of shader stages.

Shader definition source can create compile-time and runtime permutations of its shader programs.
Such permutations are defined by the `requires` keyword, followed by a boolean expression. Permutations are equivalent
to and `#if (condition) ... #endif`  statement and are used to enable or disable individual parts of a shader.
Identifiers encountered within the permutation expression are called "switches" and can either be defined externally (
for example through build options) or internally by the shader definition itself. For example, shader pass followed
by `requires API == "Vulkan" || API == "OpenGL"` will only be compiled if the target API is either Vulkan or OpenGL.

If a condition expression is prefixed with the `runtime` keyword, such condition will create a runtime shader
permutation. Runtime shader permutations are compiled into separate shader programs and can be selected at runtime by
the user based on runtime-specified switches. For example, `requires runtime COLORSPACE_SRGB` will generate a shader
program that is enabled at runtime only if the shader's `COLORSPACE_SRGB`switch is set and evaluates to `true`. Any
switches captured within the `runtime` expression will be treated as runtime switches. Runtime switches may depend on
constants, compile-time switches in which case the value of the compile-time switch is used, or other runtime switches
in which case a runtime condition is created for that switch.

Note that runtime permutations should be used sparingly, otherwise they may result in large amounts of shader code being
generated, which will increase build time and may increase runtime load time. For this reason it is recommended to only
use runtime permutations on shader passes. For example, the previous `requires runtime COLORSPACE_SRGB` permutation will
generate 2 shader programs, one where `COLORSPACE_SRGB` evaluates to `false` and another where it evaluates to `true`.
Adding another runtime switch `requires runtime(COLORSPACE_SRGB && ENABLE_BLOOM)` will generate 4 shader programs, for
all possible values of `COLORSPACE_SRGB` and `ENABLE_BLOOM`. Compile-time switches, however, do not increase runtime
permutation amount as they are treated as constants.

Permutation switches evaluate to `true` only if they are both set and their value is equal to `true`, a non-0 integer or
a non-empty string.

While the intent is to implement shaders entirely using the shader definition language, it is possible to include
external source files for shader passes and fragments. Note however, that such includes will most likely be
API-dependant and should be conditionally enabled via compile-time switches.

Shader definition assets have the `.sds` extension, which stands for Shader Definition Source.
Example of `.sds` code:

```
// Include appropriate utilities based on the current API.
include "vulkan_utils.sds" requires API == "Vulkan";
include "opengl_utils.sds" requires API == "OpenGL";

// Define a compile-time switch
switch STRING_SWITCH = "My string";
// Define a runtime switch
switch CONVERT_SRGB requires runtime COLORSPACE_SRGB;

// Since CONVERT_SRGB is a runtime switch, `runtime` keyword can be omitted.
include "srgb_utils.sds" requires CONVERT_SRGB; 

// Define a variable modifiable by the user (material variable) with a default value. 
var vignette_radius : float = 1.0;

pass bloom { /* Implement bloom effect */ };
pass vignette { /* Implement vignette effect */ };
```

Material resources are parametrized instances of shaders that store values of shader's runtime switches and variables.
Multiple materials can exist for the same shader.

## Build

## Main loop

Each iteration of the main game loop preforms the following operations:

![](main_loop_diagram.png)

## Addendum

* Editor plugins - Any plugin that provides in-editor functionality is called an editor plugin. Internally, the engine
  does not differentiate between editor plugins and regular plugins.
