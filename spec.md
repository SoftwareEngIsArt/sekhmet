## Project Structure

```
~/CekhmetProjects/my_project
    -> my_project.sekproj           (Json config file for the project containing, among other things, path to the engine install dir and list of plugin & asset package sub-projects)
    -> config                       (Directory containing "documents" of the config registry other than the build config)
        -> editor.json              (Config "document" containing project-specific editor settings, such as the current layout, )
        -> my_plugin_config.json
        -> ...
    -> assets                       (Directory containing project-specific asset packages & asset package sub-projects)
        -> external_pack.sekpak     (External asset package which is not a sub-project, but is still loaded by the engine accorging to the project config)
        -> my_package_a             (Each package receives it's own sub-directory)
            -> .manifest            (Json config file containing information about the package. If the package is a sub-project, will contain extra info about said sub-project)
            -> .import              (Directory containing asset import cache, used to store asset format handler settings)
                -> my_resource.ubj.imp
                -> my_image.png.imp
            -> .artifacts           (Directory containing asset artifacts)
                -> my_image.png.tex
            -> .metadata            (Directory containing asset metadata)
                -> my_resource.ubj.meta
            -> my_resource.ubj
            -> my_image.png
    -> plugins                      (Directory containing plugin sub-projects)
        -> my_plugin                (Each plugin receives it's own sub-directory)
            -> CMakeLists.txt       (CMake project file of the plugin's sub-project)
            -> CMakeGenerated.txt   (CMake file containing configuration generated by the engine for each project, must be included by CMakeLists.txt)
            -> project sources...
    -> bin                          (Directory containing compiled binaries of the plugin sub-projects)
        -> editor                   (In-editor binaries with debug information and editor-specific functionality)
        -> debug                    (Export binaries with debug information)
        -> release                  (Export binaries with no debug information)
```

## Config registry

Engine stores it's configuration in the config registry system. Config registry contains a tree with every node being
accessed via a cofig path, which are similar to unix file paths, with every node containing multiple children as well as
optional entry data.

Registry is separated into "documents", with each document representing an independent config tree. Documents can be
saved and restored from json files. Whenever a document is read from file or directly from a json input archive, it is
deserialized into the registry node tree. Document files, however may contain more nodes than are currently not present
within the registry, to account for this, the registry keeps track of the files the documents have been loaded from and
de-serializes the nodes as they are registered.

Editor plugins may add registry entries to the config menu, in which case the config menu can be used to edit
corresponding registry entries. Additionally, editor plugins may add registry entries to config export list, in which
case such entries will be serialized and built into the export binary. It is recommended that if the entry has ability
to provide defaults or does not need to export all it's data (ex. entries may contain data relevant only within the
editor), a different underlying type should be used for export serialization, this can reduce the amount of exported
data.

## Asset packages

## Resources

Resources are runtime types serialized into assets. Resource assets' metadata specifies the format version and the type
name of the resource (for version 1).

Every resource type must have the `sek::engine::attributes::resource_type` attribute associated with it. This
attribute is used to make the resource (de)serializable at runtime using the specified serialization archive (UBJson is
used by default).

## Editor asset import

## Editor properties

## Shader definition assets

In order to streamline & simplify shader creation process, shaders are defined using a custom node-centric language.
Assets of this intermediate shader definition language are then compiled into individual shader kernels (1 or multiple
per shader definition).

Import pipeline of the shader definition assets is roughly as follows:

1. Parse shader definition into generic shader metadata & shader programs.
2. Generate "shader program" asset aliases and the shader resource asset.
3. Generate shader source of individual shader programs for the target graphics API.
4. Compile the generated shader code into "shader program" assets for the current API.

Shader assets are fully re-imported only on changes to the shader definition file. When the graphics API changes, only
the shader source is re-generated and shader programs are re-compiled instead.

Shader definition language is used to define metadata - external variables, permutation switches and includes, shader
nodes - abstract building blocks of shader programs, shader stages - stages of an individual shader pass such as
the `vertex` and `fragment` stages, and shader passes - individual collections of shader stages.

Shader definition source can create compile-time and runtime permutations of its shader programs.
Such permutations are defined by the `requires` keyword, followed by a boolean expression. Permutations are equivalent
to and `#if (condition) ... #endif`  statement and are used to enable or disable individual parts of a shader.
Identifiers encountered within the permutation expression are called "switches" and can either be defined externally (
for example through build options) or internally by the shader definition itself. For example, shader pass followed
by `requires API == "Vulkan" || API == "OpenGL"` will only be compiled if the target API is either Vulkan or OpenGL.

If a condition expression is prefixed with the `runtime` keyword, such condition will create a runtime shader
permutation. Runtime shader permutations are compiled into separate shader programs and can be selected at runtime by
the user based on runtime-specified switches. For example, `requires runtime COLORSPACE_SRGB` will generate a shader
program that is enabled at runtime only if the shader's `COLORSPACE_SRGB`switch is set and evaluates to `true`. Any
switches captured within the `runtime` expression will be treated as runtime switches. Runtime switches may depend on
constants, compile-time switches in which case the value of the compile-time switch is used, or other runtime switches
in which case a runtime condition is created for that switch.

Note that runtime permutations should be used sparingly, otherwise they may result in large amounts of shader code being
generated, which will increase build time and may increase runtime load time. For this reason it is recommended to only
use runtime permutations on shader passes. For example, the previous `requires runtime COLORSPACE_SRGB` permutation will
generate 2 shader programs, one where `COLORSPACE_SRGB` evaluates to `false` and another where it evaluates to `true`.
Adding another runtime switch `requires runtime(COLORSPACE_SRGB && ENABLE_BLOOM)` will generate 4 shader programs, for
all possible values of `COLORSPACE_SRGB` and `ENABLE_BLOOM`. Compile-time switches, however, do not increase runtime
permutation amount as they are treated as constants.

Permutation switches evaluate to `true` only if they are both set and their value is equal to `true`, a non-0 integer or
a non-empty string.

While the intent is to implement shaders entirely using the shader definition language, it is possible to include
external source files for shader passes and fragments. Note however, that such includes will most likely be
API-dependant and should be conditionally enabled via compile-time switches.

Shader definition assets have the `.sds` extension, which stands for Shader Definition Source.
Example of `.sds` code:

```
// Include appropriate utilities based on the current API.
include "vulkan_utils.sds" requires API == "Vulkan";
include "opengl_utils.sds" requires API == "OpenGL";

// Define a compile-time switch
switch STRING_SWITCH = "My string";
// Define a runtime switch
switch CONVERT_SRGB requires runtime COLORSPACE_SRGB;

// Since CONVERT_SRGB is a runtime switch, `runtime` keyword can be omitted.
include "srgb_utils.sds" requires CONVERT_SRGB; 

// Define a variable modifiable by the user (material variable) with a default value. 
var vignette_radius : float = 1.0;

pass bloom { /* Implement bloom effect */ };
pass vignette { /* Implement vignette effect */ };
```

Material resources are parametrized instances of shaders that store values of shader's runtime switches and variables.
Multiple materials can exist for the same shader.

## Build

## Main loop

Each iteration of the main game loop preforms the following operations:

![](main_loop_diagram.png)

## Addendum

* Editor plugins - Any plugin that provides in-editor functionality is called an editor plugin. Internally, the engine
  does not differentiate between editor plugins and regular plugins.
