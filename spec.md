## Project Structure

```
~/CekhmetProjects/my_project
    -> my_project.sekproj           (Json config file for the project containing, among other things, path to the engine install dir and list of plugin & asset package sub-projects)
    -> config                       (Directory containing "documents" of the config registry other than the build config)
        -> editor.json              (Config "document" containing project-specific editor settings, such as the current layout, )
        -> my_plugin_config.json
        -> ...
    -> assets                       (Directory containing project-specific asset packages & asset package sub-projects)
        -> external_pack.sekpak     (External asset package which is not a sub-project, but is still loaded by the engine accorging to the project config)
        -> my_package_a             (Each package receives it's own sub-directory)
            -> .manifest            (Json config file containing information about the package. If the package is a sub-project, will contain extra info about said sub-project)
            -> .editor              (Directory containing editor-specific assets)
                -> assets...
            -> .import           (Directory containing asset import cache, used to store asset format handler settings)
                -> my_resource.ubj.imp
                -> my_image.png.imp
            -> .artifacts           (Directory containing asset artifacts)
                -> my_image.png.tex
            -> .metadata            (Directory containing asset metadata)
                -> my_resource.ubj.meta
            -> my_resource.ubj
            -> my_image.png
    -> plugins                      (Directory containing plugin sub-projects)
        -> my_plugin                (Each plugin receives it's own sub-directory)
            -> CMakeLists.txt       (CMake project file of the plugin's sub-project)
            -> CMakeGenerated.txt   (CMake file containing configuration generated by the engine for each project, must be included by CMakeLists.txt)
            -> project sources...
    -> bin                          (Directory containing compiled binaries of the plugin sub-projects)
        -> editor                   (In-editor binaries with debug information and editor-specific functionality)
        -> debug                    (Export binaries with debug information)
        -> release                  (Export binaries with no debug information)
```

## Build

There are 3 build types: editor, debug & release.
Plugins built from within the editor are always built using the `editor` build type. This build type includes debug
symbols, editor-only assets, and extra compile definitions such as `SEK_EDITOR`.
Plugins built for export can be either built in debug or release mode. Debug mode includes debug symbols and debug-only
assets. Release mode is fully-stripped and only contains release mode assets.

Users cannot add/remove build types, as the engine only recognizes and is able to use these 3, however they can
configure properties of these build types, such as adding compile definitions and modifying cmake and compiler flags.
In addition, users can modify and specialize build targets (ex. win-x64) and toolchains, which will be used by the 3
build types.

## Config registry

Engine stores it's configuration in the config registry system. Config registry contains a tree with every node being
accessed via a cofig path, which are similar to unix file paths, with every node containing multiple children as well as
optional entry data.

Registry is separated into "documents", with each document representing an independent config tree. Documents can be
saved and restored from json files. Whenever a document is read from file or directly from a json input archive, it is
deserialized into the registry node tree. Document files, however may contain more nodes than are currently not present
within the registry, to account for this, the registry keeps track of the files the documents have been loaded from and
de-serializes the nodes as they are registered.

Editor plugins may add registry entries to the config menu, in which case the config menu can be used to edit
corresponding registry entries. Additionally, editor plugins may add registry entries to config export list, in which
case such entries will be serialized and built into the export binary. It is recommended that if the entry has ability
to provide defaults or does not need to export all it's data (ex. entries may contain data relevant only within the
editor), a different underlying type should be used for export serialization, this can reduce the amount of exported
data.

## Editor properties

To enhance and extend in-editor asset package management, a property system is provided. Properties are special
key-value pairs which can be set or un-set depending on the build type, target, toolchain, render API, and other
user-defined requirements.

Properties are defined within the project file and are primarily used to control config-dependant asset "aliases" in
asset package projects. Aliases are used to determine which actual file should be used for each asset. You may for
example import an asset called "player_dialog.txt", which will be used in most cases, however you may want to provide a
localized version of said asset, with the localization being controlled via properties.

Properties whose requirements are met are considered "active", while others are "inactive". Property requirements are
special conditions provided by plugins (and by the editor), which, if met, activate the propertry. Properties can also
be set as "active" by default, in which case requirements will act as a blacklist instead, de-activating any properties
that meet the requirements. Property requirements are effectively boolean conditions, AND'ed together, but may also be
inverted individually. Requirements can be as simple as a direct bool evaluation, or may have an additional parameters (
ex. `graphics-api` requirement has a drop-down list parameter specifying which graphics api to require). A property may
additionally have a value associated with it, however it is not a requirement. Property value is a string associated
with the name of the property.

Properties are re-evaluated on every config update, external changes to the project file and any runtime changes to
properties (ex. an editor plugin registering a new editor property).
Whenever properties change, the project's assets (and thus resources, including the graphics pipeline) are re-loaded. In
addition, a modification of properties may trigger a re-import of certain assets.
Editor plugins may subscribe to the property modification event to provide extra functionality on property modification.
Plugins themselves, however are not reloaded, since their compilation does not depend on editor properties.

Note that property system is only available within the editor. When packages are exported, every alias is resolved
and only the relocated asset files are exported, thus there is no need for properties in exported packages. If an asset
does not have any aliases whose property dependencies are satisfied, such asset is simply ignored and not exported.

## Asset import/generation

## Resources

## Main loop

Each iteration of the main game loop preforms the following operations:

![](main_loop_diagram.png)

## Addendum

* Editor plugins - Any plugin that provides in-editor functionality is called an editor plugin. Internally, the engine
  does not differentiate between editor plugins and regular plugins.
